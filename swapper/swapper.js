// Generated by CoffeeScript 1.10.0
var checkoutMaster, exec, getBranchList, gitOptions, gitPull, reconnectBranches, renameLocalsFromTemp, renameLocalsToTemp, resetLocalBranches, swapBranches, syncLock;

syncLock = require("../util/syncLock");

if (typeof String.prototype.endsWith !== 'function') {
  String.prototype.endsWith = function(str) {
    return this.slice(-str.length) === str;
  };
}

exec = require('child_process').exec;

gitOptions = {
  cwd: process.cwd() + "/git-master"
};

gitPull = function(callback) {
  console.log("fetching all");
  return exec("git remote prune origin", gitOptions, function(error, stdout, stderr) {
    return exec("git fetch --all", gitOptions, function(error, stdout, stderr) {
      return callback();
    });
  });
};

resetLocalBranches = function(branches, callback) {
  if (branches.length === 0) {
    return checkoutMaster(callback);
  } else {
    console.log("checkout " + branches[0]);
    return exec("git checkout " + branches[0], gitOptions, function(error, stdout, stderr) {
      return exec("git pull origin " + branches[0], gitOptions, function(error, stdout, stderr) {
        return resetLocalBranches(branches.slice(1), callback);
      });
    });
  }
};

renameLocalsToTemp = function(branches, callback) {
  if (branches.length === 0) {
    return callback();
  } else {
    return exec("git branch --unset-upstream " + branches[0], gitOptions, function(error, stdout, stderr) {
      console.log("rename branch: " + branches[0] + " temp__" + branches[0]);
      return exec("git branch -m " + branches[0] + " temp__" + branches[0], gitOptions, function(error, stdout, stderr) {
        return renameLocalsToTemp(branches.slice(1), callback);
      });
    });
  }
};

renameLocalsFromTemp = function(branches, targetBranches, callback) {
  if (branches.length === 0) {
    return callback();
  } else {
    console.log("rename branch: temp__" + branches[0] + " => " + targetBranches[0]);
    return exec("git branch -m temp__" + branches[0] + " " + targetBranches[0], gitOptions, function(error, stdout, stderr) {
      return renameLocalsFromTemp(branches.slice(1), targetBranches.slice(1), callback);
    });
  }
};

reconnectBranches = function(branches, callback) {
  if (branches.length === 0) {
    return checkoutMaster(callback);
  } else {
    console.log("pushing " + branches[0] + " to origin");
    return exec("git checkout " + branches[0], gitOptions, function(error, stdout, stderr) {
      return exec("git push -uf origin " + branches[0], gitOptions, function(error, stdout, stderr) {
        return reconnectBranches(branches.slice(1), callback);
      });
    });
  }
};

checkoutMaster = function(callback) {
  console.log("checkout master");
  return exec("git checkout master", gitOptions, function(error, stdout, stderr) {
    return callback();
  });
};

swapBranches = function(branches, targetBranches, callback) {
  return syncLock.lock(function() {
    return checkoutMaster(function() {
      return gitPull(function() {
        return resetLocalBranches(branches, function() {
          return renameLocalsToTemp(branches, function() {
            return renameLocalsFromTemp(branches, targetBranches, function() {
              return reconnectBranches(branches, function() {
                callback();
                return syncLock.release();
              });
            });
          });
        });
      });
    });
  });
};

getBranchList = function(callback) {
  return syncLock.lock(function() {
    return gitPull(function() {
      return exec("git branch -r", gitOptions, function(error, stdout, stderr) {
        var branches, i, len, line, lines;
        branches = [];
        lines = stdout.toString().split("\n");
        for (i = 0, len = lines.length; i < len; i++) {
          line = lines[i];
          if (line && !(line.endsWith("/master"))) {
            branches.push(line.substr(line.lastIndexOf("/") + 1));
          }
        }
        callback(branches);
        return syncLock.release();
      });
    });
  });
};

exports.swapBranches = swapBranches;

exports.getBranchList = getBranchList;
