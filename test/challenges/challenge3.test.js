// Generated by CoffeeScript 1.10.0
var _, chai, challengeUtils, expect, subject;

chai = require("chai");

subject = require("../../challenges/challenge3");

challengeUtils = require("../../challenges/challengeUtils");

_ = require("underscore");

expect = chai.expect;

describe('challenge3', function() {
  it('returns a string of FBLR for instructions', function() {
    var challenge;
    challenge = subject.challenge();
    expect(challenge.question.instructions.length).to.be.above(0);
    return _.each(challenge.question.instructions, function(char) {
      return expect(['F', 'B', 'L', 'R']).to.include(char);
    });
  });
  it('provides startX and startY as numbers', function() {
    var challenge;
    challenge = subject.challenge();
    expect(challenge.question.startX).to.be.a('number');
    return expect(challenge.question.startY).to.be.a('number');
  });
  it('provides treasureX and treasureY as numbers', function() {
    var challenge;
    challenge = subject.challenge();
    expect(challenge.question.treasureX).to.be.a('number');
    return expect(challenge.question.treasureY).to.be.a('number');
  });
  it('provides correct endX and endY', function() {
    var a, challenge, expectedEnd, instructions, q;
    challenge = subject.challenge();
    q = challenge.question;
    a = challenge.answer;
    instructions = q.instructions.split('');
    expectedEnd = challengeUtils.calculateEndPosition(instructions, [q.startX, q.startY]);
    return expect([a.endX, a.endY]).to.deep.equal(expectedEnd);
  });
  it('marks the treasure as found when it should', function() {
    var a, challenge, q;
    challenge = subject.getChallenge(true);
    q = challenge.question;
    a = challenge.answer;
    return expect(a.treasureFound).to.be["true"];
  });
  it('marks the treasure as not found when it should', function() {
    var a, challenge, q;
    challenge = subject.getChallenge(false);
    q = challenge.question;
    a = challenge.answer;
    return expect(a.treasureFound).to.be["false"];
  });
  it('places the treasure on the route when found', function() {
    var a, challenge, instructions, q, route;
    challenge = subject.getChallenge(true);
    q = challenge.question;
    a = challenge.answer;
    instructions = q.instructions.split('');
    route = challengeUtils.calculatePath(instructions, [q.startX, q.startY]);
    return expect(route).to.contain.something.that.deep.equals([q.treasureX, q.treasureY]);
  });
  it('places the treasure off the route when not found', function() {
    var a, challenge, instructions, q, route;
    challenge = subject.getChallenge(false);
    q = challenge.question;
    a = challenge.answer;
    instructions = q.instructions.split('');
    route = challengeUtils.calculatePath(instructions, [q.startX, q.startY]);
    return expect(route).not.to.contain.something.that.deep.equals([q.treasureX, q.treasureY]);
  });
  return it('places the treasure on the route dependent on random selection', function() {
    var a, challenge, instructions, q, route;
    challenge = subject.challenge();
    q = challenge.question;
    a = challenge.answer;
    instructions = q.instructions.split('');
    route = challengeUtils.calculatePath(instructions, [q.startX, q.startY]);
    if (a.treasureFound) {
      return expect(route).to.contain.something.that.deep.equals([q.treasureX, q.treasureY]);
    } else {
      return expect(route).not.to.contain.something.that.deep.equals([q.treasureX, q.treasureY]);
    }
  });
});
